//handles phase2: Lens Into The Past
//shows stories of the past over 5 stages (text and images)
//they are generated by ChatGPT and Dall-E API
//users can prompt their own stories and have them displayed 
//exports the tab body component of phase2

import React, { useState, useEffect, useRef } from "react";
import { throttle } from 'lodash';
import './styles/stylePhase2.css';
import Phase2Form from './phase2Input';
import { fetchData, BaseUrl, requestLimitTracker } from "./helper";


 //a stage in the story
 //contains a div that contains the stage title,
 //stage image and stage contents
 //handles fetching images individually 
function StoryStage(props){
  //img URL
  const [imgSrc, setImgSrc] = useState(null);
  //fetch the image
  const fetchInfo = async () => {
    const imgUrl = BaseUrl.phase2 +`getImage/${props.storyId}/${props.stageNumber}`;
    try {
      const response = await fetchData(imgUrl);
      //check if the response is valid
      if (response.ok) {
        //create a blob
        const blob = await response.blob();
        setImgSrc(URL.createObjectURL(blob));
      } else {
        console.error('Failed to fetch image');
      }
    } catch (error) {
      console.error('Error fetching data:', error);
    } finally {//set the image to to available
      props.updateStageAvailable(props.stageNumber-1, 1)
    }
  }

  //fetch images on load
  useEffect(()=> {
    fetchInfo();
  }, [])

  //set up classes for displaying the stage (i.e. title, text, image)
  //assign a class if the image is currently active (i.e. displayed)
  const cl = props.slideIndex === props.stageNumber ? 'storyStageActive' : '';
  //if the imgSrc is null, don't display it
  const c2 = imgSrc === null ? 'displayNone' : '';
  //set the imgSrc if it has been fetched and available for display, 
  //otherwise, set a default loading img
  const imgSrcUrl = imgSrc !== null ? imgSrc : 'loadingGif.gif'
  return(
    <div className={`storyStage ${cl}`}>
      <h4 className={`storyStageTitle ${c2}`}>
        {props.stageNumber} - {props.stageTitle}
      </h4>
      <img src={imgSrcUrl} alt="stage img"></img>
      <p className={`storyStageStory ${c2}`}>
        {props.stageStory}
      </p>
    </div>
  )
}

//a Dot is a compoenent that represents a circle for each image
//it represents the image's status if the image is available (i.e. fetched)
//or if the image is the one currently in the display. also clicking on dot
//will take you to the image it represent
function Dot({stageNumber, slideIndex, storyStageAvailable, setSlideIndex}){
  const cl = slideIndex === stageNumber ? 'dotAvailable' : '';
  const c2 = storyStageAvailable[stageNumber-1] === 1 ? 'dotLoaded' : '';
  return (
    <span className={`dot ${cl} ${c2}`} onClick={() => setSlideIndex(stageNumber)}></span>
  )
}

//story compoenent
//encompasses the title and the 5 stages of the each
function Story(props){
  //separate the story from its 5 stages
  const storyStages = Object.values(props).slice(0, 5);
  const story = props[Object.keys(props).length - 1];

  //an array that tracks the availablity of the image
  //an image is available after it has been fetched from the backend
  //1 for available, 0 otherwise
  //used to manage the Dot for the image and display loading or the image itself
  const [storyStageAvailable, setStoryStageAvailable] = useState(() => Array.from({ length: storyStages.length }, () => 0));
  const updateStageAvailable = (index, newValue) => {
    setStoryStageAvailable(prevArray => {
      const newArrayCopy = [...prevArray];
      newArrayCopy[index] = newValue;
      return newArrayCopy;
    });
  };

  //image that is currently in display, start with 1
  const [slideIndex, setSlideIndex] = useState(1);

  //next/prev button click function, inc/dec the slideIndex
  //allows image rotation (i.e. when reaching last image, the next image is the first one)
  function updateSlideIndex(n) {
    if (slideIndex >= storyStages.length && n === 1)
      setSlideIndex(1);
    else if (slideIndex === 1 && n === -1)
      setSlideIndex(storyStages.length);
    else
      setSlideIndex(prevIndex => prevIndex += n);
  }

  return(
    <>
      <h3 className="storyArticleTitle" title={story.storyPrompt} data-bs-toggle="tooltip" data-bs-placement="top">
          {story.storyPrompt}
      </h3>
      <article className="storyArticle" id={story.storyId}>
        <a className="prev" onClick={() => updateSlideIndex(-1)}>&#10094;</a>
        <a className="next" onClick={() => updateSlideIndex(1)}>&#10095;</a>
        {storyStages.map(entry => <StoryStage {...entry} storyStageAvailable={storyStageAvailable} updateStageAvailable={updateStageAvailable} storyId={story.storyId} slideIndex={slideIndex} key={entry.stageNumber}/> )}
        <div className="dotCotnainer">
          {storyStages.map(dot => <Dot {...dot} storyStageAvailable={storyStageAvailable} slideIndex={slideIndex} setSlideIndex={setSlideIndex} key={dot.stageNumber}/>)}
        </div>
      </article>
    </>
  )
}

function Tooltip({value}){
  return(
      <span classclassName="tooltiptext">value</span>
  )
}

//display all the old stories (and their stages),
//fetches more data when the user scrolls
function OldStories(){
  //list of entries to be retrieved
  const [data, setData] = useState([]);
  //throttles the scrolling, await fetching more data
  const [fetchingData, setFetchingData] = useState(false);
  //batches, each scroll is one batch, begins with one (a batch is a story)
  const [storyNumber, setStoryNumber] = useState(0);
  //to display error message if any
  const [error, setError] = useState(false);
  //if the server does not return anymore stories, this variable will stop further requests
  const [noMoreStories, setNoMoreStories] = useState(false);

  //async fetch data from the api.
  //called on page load and everytime the user
  //reaches a certain point in scrolling
  //newBatch is true when resetting the previous data, usually
  //when new story is generated is updated and the old data are obsolete
  const fetchInfo = async () => {
    if (noMoreStories)
      return;
    const phase2Url = BaseUrl.phase2 + `${storyNumber}`;
    setFetchingData(true);
    try {
      const response = await fetchData(phase2Url);
      //check if the response is valid
      if (response.ok) {
          //get the new data
          const newData = await response.json();
          //append them to the previous data
          setData(prevData => [...prevData, ...newData]);
          //increment the story number
          setStoryNumber(prevNum => prevNum + 1);
        } else if (response.status === 404) {//no more stories
          // console.error('Not Found:', response.statusText);
          setNoMoreStories(true);
        } else {
          setError(true);
        }
      } catch (errorReq) {
        console.error('Error fetching data:', errorReq);
      } finally {
          setFetchingData(false);
      }
  }

  //fetch initial data 
  useEffect(() => {
      fetchInfo();
  }, [])

  //set the scrolling event
  useEffect(() => {
    //event callback function used to fetch data 
    //when the user reaches a certain point in the page
    //it uses debounce to throttle calls to the api
    const handleScroll = throttle(() => {
      const scrollHeight = document.documentElement.scrollHeight;
      const scrollTop = document.documentElement.scrollTop;
      const windowHeight = window.innerHeight;
      const scrollLimit = 1000;

      if (!fetchingData && scrollTop + windowHeight >= (scrollHeight-scrollLimit)) {
        fetchInfo();
        if (noMoreStories)//remove the scrolling if no more stories
          window.removeEventListener('scroll', handleScroll);
      }
    }, 200);
    
    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [storyNumber, fetchingData]);

  //if the data are not loaded/being loaded
  if (error)
      return <h4>Failed to get data :(</h4>;
  else if (data.length === 0)
    return <h4>Loading...</h4>; //todo: loading icon
  
  return (
    <>
      {data.map(entry => <Story {...entry} key={entry.entryId}/>)}
    </>
  )
}

//displays the story as prompted by the user
function CurrentStory({storyPrompt, setLoadingSpinner, setFormComponent}){
  //the story and its components to be rendered, initially an empty
  //element until the storyPrompt is updated by the user
  const [renderComponent, setRenderComponent] = useState(<></>);
  //prevents from being rendered on the first page load,
  //useEffect will only be called when storyPrompt is updated by the user
  const isFirstRender = useRef(true)
  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    
    //send prompt to the backend
    const fetchInfo = async () => {
      const fetchUrl = BaseUrl.phase2 + `makeRequest/${storyPrompt}`;
      try {
        setLoadingSpinner(true);
        const response = await fetchData(fetchUrl);
        //check if the response is valid
        if (response.ok) {
            //get the new data
            const newData = await response.json();
            //pass the new data to the story compoenent
            setRenderComponent(<Story {...newData[0]} />);
          } else if (response.status === 429) {//reached prompts limit for the day
            //set the request limit tracker to inform the user when to come back
            //and can prompt again
            const errorData = await response.json();
            requestLimitTracker.setTracker(errorData.checkAgainTime, errorData.reason);
            //set the display for the request limit tracker
            setFormComponent(requestLimitTracker.timeComp());
          } else if (response.status === 422){//something went wrong
            setRenderComponent(<h4>Request failed :(</h4>);
          }
        } catch (errorReq) {
          console.error('Error fetching data:', errorReq);
        } finally{
          setLoadingSpinner(false);
        }
    }
    
    fetchInfo();
  }, [storyPrompt]);

  return renderComponent;
}

//the component of phase2
//it displays all the stories (and their stages),
//handles user input, and fetches more data
//when the user scrolls
function TabBodyPhase2(){
  //story prompt of the data to be retrieved
  const [storyPrompt, setStoryPrompt] = useState("Story");

  //check if the user can prompt, this is to prevent the display of the form
  //so the user do not spam prompts and their requests count have already reached daily limit anyways
  const [formComponent, setFormComponent] = useState(requestLimitTracker.hasTimePassed() ? <Phase2Form setStoryPrompt={setStoryPrompt} /> : requestLimitTracker.timeComp());

  //displays a spinner when prompting, removed when the story has been fetched
  const [loadingSpinner, setLoadingSpinner] = useState(false);

  return(
    <>
      {formComponent}
      <h4>One upon a time.....</h4>
      <hr/>
      <CurrentStory storyPrompt={storyPrompt} setLoadingSpinner={setLoadingSpinner} setFormComponent={setFormComponent}/>
      {loadingSpinner &&
        <>
          <h4>Do not refresh the page</h4>
          <div className="spinner-border spinnerContainer">
            <span className="visually-hidden">Loading...</span>
          </div>
        </>
      }
      <OldStories key={'stories'}/>
    </>
  )
}

export {TabBodyPhase2};